export declare const vueHotReloadCode = "\nvar Vue // late bind\nvar version\nvar __VUE_HMR_RUNTIME__ = Object.create(null)\nvar map = Object.create(null)\nif (typeof window !== 'undefined') {\n\twindow.__VUE_HMR_RUNTIME__ = __VUE_HMR_RUNTIME__\n}\nvar installed = false\nvar isBrowserify = false\nvar initHookName = 'beforeCreate'\n\n__VUE_HMR_RUNTIME__.install = function (vue, browserify) {\n\tif (installed) { return }\n\tinstalled = true\n\n\tVue = vue.__esModule ? vue.default : vue\n\tversion = Vue.version.split('.').map(Number)\n\tisBrowserify = browserify\n\n\t// compat with < 2.0.0-alpha.7\n\tif (Vue.config._lifecycleHooks.indexOf('init') > -1) {\n\t\tinitHookName = 'init'\n\t}\n\n\t__VUE_HMR_RUNTIME__.compatible = version[0] >= 2\n\tif (!__VUE_HMR_RUNTIME__.compatible) {\n\t\tconsole.warn(\n\t\t\t'[HMR] You are using a version of vue-hot-reload-api that is ' +\n\t\t\t'only compatible with Vue.js core ^2.0.0.'\n\t\t)\n\t\treturn\n\t}\n}\n\n/**\n * Create a record for a hot module, which keeps track of its constructor\n * and instances\n *\n * @param {String} id\n * @param {Object} options\n */\n\n__VUE_HMR_RUNTIME__.createRecord = function (id, options) {\n\tif(map[id]) { return }\n\n\tvar Ctor = null\n\tif (typeof options === 'function') {\n\t\tCtor = options\n\t\toptions = Ctor.options\n\t}\n\tmakeOptionsHot(id, options)\n\tmap[id] = {\n\t\tCtor: Ctor,\n\t\toptions: options,\n\t\tinstances: []\n\t}\n}\n\n/**\n * Check if module is recorded\n *\n * @param {String} id\n */\n\n__VUE_HMR_RUNTIME__.isRecorded = function (id) {\n\treturn typeof map[id] !== 'undefined'\n}\n\n/**\n * Make a Component options object hot.\n *\n * @param {String} id\n * @param {Object} options\n */\n\nfunction makeOptionsHot(id, options) {\n\tif (options.functional) {\n\t\tvar render = options.render\n\t\toptions.render = function (h, ctx) {\n\t\t\tvar instances = map[id].instances\n\t\t\tif (ctx && instances.indexOf(ctx.parent) < 0) {\n\t\t\t\tinstances.push(ctx.parent)\n\t\t\t}\n\t\t\treturn render(h, ctx)\n\t\t}\n\t} else {\n\t\tinjectHook(options, initHookName, function() {\n\t\t\tvar record = map[id]\n\t\t\tif (!record.Ctor) {\n\t\t\t\trecord.Ctor = this.constructor\n\t\t\t}\n\t\t\trecord.instances.push(this)\n\t\t})\n\t\tinjectHook(options, 'beforeDestroy', function() {\n\t\t\tvar instances = map[id].instances\n\t\t\tinstances.splice(instances.indexOf(this), 1)\n\t\t})\n\t}\n}\n\n/**\n * Inject a hook to a hot reloadable component so that\n * we can keep track of it.\n *\n * @param {Object} options\n * @param {String} name\n * @param {Function} hook\n */\n\nfunction injectHook(options, name, hook) {\n\tvar existing = options[name]\n\toptions[name] = existing\n\t\t? Array.isArray(existing) ? existing.concat(hook) : [existing, hook]\n\t\t: [hook]\n}\n\nfunction tryWrap(fn) {\n\treturn function (id, arg) {\n\t\ttry {\n\t\t\tfn(id, arg)\n\t\t} catch (e) {\n\t\t\tconsole.error(e)\n\t\t\tconsole.warn(\n\t\t\t\t'Something went wrong during Vue component hot-reload. Full reload required.'\n\t\t\t)\n\t\t}\n\t}\n}\n\nfunction updateOptions (oldOptions, newOptions) {\n\tfor (var key in oldOptions) {\n\t\tif (!(key in newOptions)) {\n\t\t\tdelete oldOptions[key]\n\t\t}\n\t}\n\tfor (var key$1 in newOptions) {\n\t\toldOptions[key$1] = newOptions[key$1]\n\t}\n}\n\n__VUE_HMR_RUNTIME__.rerender = tryWrap(function (id, options) {\n\tvar record = map[id]\n\tif (!options) {\n\t\trecord.instances.slice().forEach(function (instance) {\n\t\t\tinstance.$forceUpdate()\n\t\t})\n\t\treturn\n\t}\t\n\tif (typeof options === 'function') {\n\t\toptions = options.options\n\t}\n\tif(record.functional){\n\t\trecord.render = options.render\n\t\trecord.staticRenderFns = options.staticRenderFns\n\t\t__VUE_HMR_RUNTIME__.reload(id, record)\n\t\treturn\n\t}\n\tif (record.Ctor) {\n\t\trecord.Ctor.options.render = options.render\n\t\trecord.Ctor.options.staticRenderFns = options.staticRenderFns\n\t\trecord.instances.slice().forEach(function (instance) {\n\t\t\tinstance.$options.render = options.render\n\t\t\tinstance.$options.staticRenderFns = options.staticRenderFns\n\t\t\t// reset static trees\n\t\t\t// pre 2.5, all static trees are cached together on the instance\n\t\t\tif (instance._staticTrees) {\n\t\t\t\tinstance._staticTrees = []\n\t\t\t}\n\t\t\t// 2.5.0\n\t\t\tif (Array.isArray(record.Ctor.options.cached)) {\n\t\t\t\trecord.Ctor.options.cached = []\n\t\t\t}\n\t\t\t// 2.5.3\n\t\t\tif (Array.isArray(instance.$options.cached)) {\n\t\t\t\tinstance.$options.cached = []\n\t\t\t}\n\n\t\t\t// post 2.5.4: v-once trees are cached on instance._staticTrees.\n\t\t\t// Pure static trees are cached on the staticRenderFns array\n\t\t\t// (both already reset above)\n\n\t\t\t// 2.6: temporarily mark rendered scoped slots as unstable so that\n\t\t\t// child components can be forced to update\n\t\t\tvar restore = patchScopedSlots(instance)\n\t\t\tinstance.$forceUpdate()\n\t\t\tinstance.$nextTick(restore)\n\t\t})\n\t} else {\n\t\t// functional or no instance created yet\n\t\trecord.options.render = options.render\n\t\trecord.options.staticRenderFns = options.staticRenderFns\n\n\t\t// handle functional component re-render\n\t\tif (record.options.functional) {\n\t\t\t// rerender with full options\n\t\t\tif (Object.keys(options).length > 2) {\n\t\t\t\tupdateOptions(record.options, options)\n\t\t\t} else {\n\t\t\t\t// template-only rerender.\n\t\t\t\t// need to inject the style injection code for CSS modules\n\t\t\t\t// to work properly.\n\t\t\t\tvar injectStyles = record.options._injectStyles\n\t\t\t\tif (injectStyles) {\n\t\t\t\t\tvar render = options.render\n\t\t\t\t\trecord.options.render = function (h, ctx) {\n\t\t\t\t\t\tinjectStyles.call(ctx)\n\t\t\t\t\t\treturn render(h, ctx)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trecord.options._Ctor = null\n\t\t\t// 2.5.3\n\t\t\tif (Array.isArray(record.options.cached)) {\n\t\t\t\trecord.options.cached = []\n\t\t\t}\n\t\t\trecord.instances.slice().forEach(function (instance) {\n\t\t\t\tinstance.$forceUpdate()\n\t\t\t})\n\t\t}\n\t}\n})\n\n__VUE_HMR_RUNTIME__.reload = tryWrap(function (id, options) {\n\tvar record = map[id]\n\tif (options) {\n\t\tif (typeof options === 'function') {\n\t\t\toptions = options.options\n\t\t}\n\t\tmakeOptionsHot(id, options)\n\t\tif (record.Ctor) {\n\t\t\tif (version[1] < 2) {\n\t\t\t\t// preserve pre 2.2 behavior for global mixin handling\n\t\t\t\trecord.Ctor.extendOptions = options\n\t\t\t}\n\t\t\tvar newCtor = record.Ctor.super.extend(options)\n\t\t\t// prevent record.options._Ctor from being overwritten accidentally\n\t\t\tnewCtor.options._Ctor = record.options._Ctor\n\t\t\trecord.Ctor.options = newCtor.options\n\t\t\trecord.Ctor.cid = newCtor.cid\n\t\t\trecord.Ctor.prototype = newCtor.prototype\n\t\t\tif (newCtor.release) {\n\t\t\t\t// temporary global mixin strategy used in < 2.0.0-alpha.6\n\t\t\t\tnewCtor.release()\n\t\t\t}\n\t\t} else {\n\t\t\tupdateOptions(record.options, options)\n\t\t}\n\t}\n\trecord.instances.slice().forEach(function (instance) {\n\t\tif (instance.$vnode && instance.$vnode.context) {\n\t\t\tinstance.$vnode.context.$forceUpdate()\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\t'Root or manually mounted instance modified. Full reload required.'\n\t\t\t)\n\t\t}\n\t})\n})\n\n// 2.6 optimizes template-compiled scoped slots and skips updates if child\n// only uses scoped slots. We need to patch the scoped slots resolving helper\n// to temporarily mark all scoped slots as unstable in order to force child\n// updates.\nfunction patchScopedSlots (instance) {\n\tif (!instance._u) { return }\n\t// https://github.com/vuejs/vue/blob/dev/src/core/instance/render-helpers/resolve-scoped-slots.js\n\tvar original = instance._u\n\tinstance._u = function (slots) {\n\t\ttry {\n\t\t\t// 2.6.4 ~ 2.6.6\n\t\t\treturn original(slots, true)\n\t\t} catch (e) {\n\t\t\t// 2.5 / >= 2.6.7\n\t\t\treturn original(slots, null, true)\n\t\t}\n\t}\n\treturn function () {\n\t\tinstance._u = original\n\t}\n}\nexport default __VUE_HMR_RUNTIME__\n";
